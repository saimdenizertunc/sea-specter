[
  {
    "id": "cmlwu7f120000af520rzaf0iu",
    "title": "test",
    "slug": "test",
    "excerpt": "test",
    "content": "test",
    "coverImage": null,
    "postCoverImage": null,
    "published": true,
    "publishedAt": "2026-02-21T21:58:32.165Z",
    "authorId": "user_39zq9z3be5wCpXZI3UdR89uVSvN",
    "createdAt": "2026-02-21T21:34:51.203Z",
    "updatedAt": "2026-02-21T21:58:32.180Z"
  },
  {
    "id": "cmlwurf4t0000an228ivx0kof",
    "title": "test2",
    "slug": "test2",
    "excerpt": "test2",
    "content": "a",
    "coverImage": "https://gnstmp6tph.ufs.sh/f/f3c2Q4HD6EpRZ8UlWvad3CyVw9jR4kMmSplbr56qF8KcxQhW",
    "postCoverImage": null,
    "published": true,
    "publishedAt": "2026-02-21T21:50:31.817Z",
    "authorId": "user_39zq9z3be5wCpXZI3UdR89uVSvN",
    "createdAt": "2026-02-21T21:50:23.184Z",
    "updatedAt": "2026-02-21T22:15:03.998Z"
  },
  {
    "id": "cmlwvuddd0000w6s74zeajjyz",
    "title": "wrter",
    "slug": "wetw",
    "excerpt": "sdgsdg",
    "content": "<PullQuote>Light doesn't wait for anyone â€” not even the people who've spent their lives chasing it. </PullQuote>",
    "coverImage": "https://gnstmp6tph.ufs.sh/f/f3c2Q4HD6EpR7cdIr2hAd3OVhM4SzRrHiNWAKJvtkZ0wcCqf",
    "postCoverImage": "https://gnstmp6tph.ufs.sh/f/f3c2Q4HD6EpRfOxIReHD6EpRhSwP9glQdaAoIOCsGev04muU",
    "published": true,
    "publishedAt": "2026-02-21T22:20:49.995Z",
    "authorId": "user_39zq9z3be5wCpXZI3UdR89uVSvN",
    "createdAt": "2026-02-21T22:20:41.767Z",
    "updatedAt": "2026-02-21T23:16:12.800Z"
  },
  {
    "id": "cmlwzimca0000ayxdep07d45b",
    "title": "A Realistic Comparison: Opus 4.6 vs. Codex 5.3 for Everyday Coding",
    "slug": "comparison",
    "excerpt": "A Realistic Comparison: Opus 4.6 vs. Codex 5.3 for Everyday Coding",
    "content": "## A Realistic Comparison: Opus 4.6 vs. Codex 5.3 for Everyday Coding\r\n\r\nWe are currently in an AI model renaissance, flooded with incredible open-weight models and powerful proprietary options from leading labs. If you are an engineer sitting down to write code every day, you might be wondering which of the top-tier closed models is actually the best fit for your workflow.\r\n\r\nAfter heavily testing Opus 4.6 and Codex 5.3, racking up hours of inference and pushing both models to their limits, here is a realistic breakdown of how they compare in the trenches.\r\n\r\n## The Cost and Subscription Reality\r\n\r\nPricing for these models is a bit complex, especially since many developers rely on subsidized `$200/month` subscription tiers rather than paying direct API costs.\r\n\r\nOpus 4.6 is undeniably expensive at the API level. It costs `$25` per million output tokens and `$5` per million input tokens, with its \"fast mode\" costing up to six times more.\r\n\r\nCodex 5.3 is not fully available over the API yet, but it is expected to align closer to Codex 5.2 pricing, around `$1.75` per million input tokens and `$14` per million output tokens.\r\n\r\nWhen looking at monthly subscriptions, Codex offers a much more generous allowance. Heavy usage barely makes a dent in Codex quotas; you can grind all week and only burn through roughly `8%` to `16%` of your limit. In contrast, a single prompt using Claude Code for Opus can instantly burn through about `3%` of your hourly limit.\r\n\r\n## The Tale of Two Engineers\r\n\r\nWhen it comes to coding intelligence, these models operate with fundamentally different philosophies.\r\n\r\nCodex is the \"measure twice, cut once\" model. It behaves like a thorough, somewhat paranoid engineer who is terrified of causing an outage. If Codex encounters a blocker, such as a package conflict during a migration, it will build temporary patches, solve the problem, then clean the patches up afterward.\r\n\r\nIt is excellent at navigating massive codebases because it actively hunts for existing patterns and mimics the style already in place. However, this same thoroughness can sometimes become self-defeating, causing Codex to get trapped in a \"fix everything\" loop and generate thousands of lines of low-value tests.\r\n\r\nOpus is the over-caffeinated engineer who just wants to ship. It is a \"cut three times and deal with the consequences\" model. Opus is much faster at unblocking itself by ignoring blockers and trimming project scope to move around them.\r\n\r\nIt will often get a working prototype on your screen faster, but it can leave a trail of broken type definitions, disconnected frontends, and even obvious security vulnerabilities in its wake.\r\n\r\n## The Harness Experience: CLI vs. Claude Code\r\n\r\nHow you interact with these models heavily influences the experience.\r\n\r\nInteracting with Opus through Claude Code can be frustrating. The harness can fail to compact, drop attachments if you type too fast, and lose queued commands (the \"stash\") when switching threads or pasting images. If Opus gets off-track during a multi-step plan, interrupting it can cause it to lose context entirely.\r\n\r\nCodex, used via CLI or desktop app, is currently much more reliable and steerable. If Codex makes a mistake on step two of a plan, you can interrupt, correct course, and it will usually adjust smoothly and continue.\r\n\r\n## Where Opus Shines\r\n\r\nDespite its flaws as a deep-system engineer, Opus still has critical strengths:\r\n\r\n- **Frontend design:** Opus significantly outperforms Codex on UI and visual design tasks. A strong workflow is to let Codex build backend functionality, then bring in Opus to elevate the interface.\r\n- **\"Using my laptop\" tasks:** For tweaking a `.zshrc`, configuring Git, or managing SSH/network setup, Opus is fast and pleasant for quick, isolated tasks.\r\n- **Modern frameworks:** Opus is generally better with newer stacks like Svelte and Convex, where Codex can sometimes miss framework-specific patterns.\r\n\r\n## Final Verdict\r\n\r\nIf you have to choose one model for real, everyday software engineering, Codex 5.3 is the winner. It is better at hard problems, large codebase migrations, and ensuring no stone is left unturned. It is less likely to cut corners and more trustworthy for maintaining security and integrity in production systems.\r\n\r\nThat said, Opus is often more fun to use. It can feel sharper in conversation and quickly spin up beautiful mockups that make you feel unusually productive.\r\n\r\nUltimately, the best approach is to use both when possible: let Opus draft UI and provide creative unblockers, then use Codex to clean up, implement deep logic, and harden the codebase.\r\n",
    "coverImage": "https://gnstmp6tph.ufs.sh/f/f3c2Q4HD6EpRcSFoBGZ8PDANG1bvnWMr6iVlhz7UCJFTLOu2",
    "postCoverImage": "https://gnstmp6tph.ufs.sh/f/f3c2Q4HD6EpRBeayUWXq1sbS8Cr7OtcNJ2A6u4eivzwgRTho",
    "published": true,
    "publishedAt": "2026-02-22T00:03:35.865Z",
    "authorId": "user_39zq9z3be5wCpXZI3UdR89uVSvN",
    "createdAt": "2026-02-22T00:03:31.984Z",
    "updatedAt": "2026-02-22T00:03:35.876Z"
  }
]